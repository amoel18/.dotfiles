global !p
texMathZones = ['texMathZone' + x for x in ['', 'X', 'XX', 'Env', 'EnvStarred', 'Ensured']]
texIgnoreMathZones = ['texMathTextArg']
# texMathZones = ['texMathZone' + x for x in ['A', 'AS', 'B', 'BS', 'C', 'CS', 'D', 'DS', 'E', 'ES', 'F', 'FS', 'G', 'GS', 'H', 'HS', 'I', 'IS', 'J', 'JS', 'K', 'KS', 'L', 'LS', 'DS', 'V', 'W', 'X', 'Y', 'Z', 'AmsA', 'AmsB', 'AmsC', 'AmsD', 'AmsE', 'AmsF', 'AmsG', 'AmsAS', 'AmsBS', 'AmsCS', 'AmsDS', 'AmsES', 'AmsFS', 'AmsGS' ]]
# texIgnoreMathZones = ['texMathText']
texMathZoneIds = vim.eval('map('+str(texMathZones)+", 'hlID(v:val)')")
texIgnoreMathZoneIds = vim.eval('map('+str(texIgnoreMathZones)+", 'hlID(v:val)')")

ignore = texIgnoreMathZoneIds[0]
def math():
        synstackids = vim.eval("synstack(line('.'), col('.') - (col('.')>=2 ? 1 : 0))")
        try:
      	  first = next(i for i in reversed(synstackids) if i in texIgnoreMathZoneIds or i in texMathZoneIds)
      	  return first != ignore
        except StopIteration:
      	  return False
endglobal
# global !p
# texMathZones = ['texMathZone'+x for x in ['A', 'AS', 'B', 'BS', 'C', 'CS', 'D', 'DS', 'V', 'W', 'X', 'Y', 'Z']]
# # If you have http://www.drchip.org/astronaut/vim/vbafiles/amsmath.vba.gz,
# # you want to add:
# # texMathZones += ['texMathZone'+x for x in ['E', 'ES', 'F', 'FS', 'G', 'GS', 'H', 'HS', 'I', 'IS', 'J', 'JS', 'K', 'KS', 'L', 'LS']]
# texIgnoreMathZones = ['texMathText']

# texMathZoneIds = vim.eval('map('+str(texMathZones)+", 'hlID(v:val)')")
# texIgnoreMathZoneIds = vim.eval('map('+str(texIgnoreMathZones)+", 'hlID(v:val)')")

# def isMath():
#     synstackids = vim.eval("synstack(line('.'), col('.') - (col('.')>=2 ? 1 : 0))")
#     if not set(texIgnoreMathZoneIds).isdisjoint(synstackids):
#         return False
#     return not set(texMathZoneIds).isdisjoint(synstackids)
#     # isdisjoint() can short-circuit as soon as a match is found

# endglobal

snippet templatebasic "Basic template" b

\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage[dutch]{babel}
\usepackage{amsmath, amssymb}


% figure support
\usepackage{import}
\usepackage{xifthen}
\pdfminorversion=7
\usepackage{pdfpages}
\usepackage{transparent}
\newcommand{\incfig}[1]{%
	\def\svgwidth{\columnwidth}
	\import{./figures/}{#1.pdf_tex}
}

\pdfsuppresswarningpagegroup=1

\begin{document}
	$0
\end{document}
endsnippet

snippet template "template" b
\documentclass[danish,a4paper,11pt]{article}
\usepackage{lmodern}
% Some basic packages
\makeatletter
\def\input@path{{../}}
\makeatother
\input{Preamble.tex}
\title{$1}
\author{Anders Kinch Møller}
\date{}
\begin{document}
\maketitle
$0
\end{document}
endsnippet


snippet templateTest "Basic template" b
\documentclass[danish,a4paper,11pt]{article}
\pdfmapfile{+libertinust1math.map}
%\usepackage{amssymb}% don't use with newtxmath
%SetFonts
% libertine+newtxmath
\usepackage{libertine}
\usepackage{libertinust1math}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[varqu,varl]{zi4}% inconsolata
\usepackage{bm}
\usepackage[lite]{mtpro2}
\usepackage{array}
%\useosf % use oldstyle figures except in math
\usepackage[cal=stix,scr=boondoxo]{mathalfa}% less slanted than STIX cal
\usepackage{booktabs}
\usepackage{fonttable}
\usepackage[supstfm=libertinesups,%
  supscaled=1.2,%
  raised=-.13em]{superiors}
%SetFonts
%\usepackage{lmodern}
 \usepackage[margin=1in]{geometry}
 \usepackage[parfill]{parskip}% Begin paragraphs with an empty line rather than an indent
 \usepackage{textcomp}
 \usepackage{float}
 \usepackage{babel}
 \usepackage{amsmath, amssymb, amsthm}
 \usepackage{graphicx}
 \usepackage{physics}
 \hfuzz=5.002pt
% % figure support
 \usepackage{import}
 \pdfminorversion=7
\usepackage{pdfpages}
% \pdfsuppresswarningpagegroup=1
\pagestyle{empty}

\title{$1}
\author{Anders Kinch Møller}
\date{}
\begin{document}
\maketitle

    $0

\end{document}
endsnippet



snippet beg "begin{} / end{}" bA
\\begin{$1}
	$0
\\end{$1}
endsnippet

priority 100
snippet ... "ldots" iA
\ldots
endsnippet

snippet table "Table environment" b
\begin{table}[${1:htpb}]
	\centering
	\caption{${2:caption}}
	\label{tab:${3:label}}
	\begin{tabular}{${5:c}}
	$0${5/((?<=.)c|l|r)|./(?1: & )/g}
	\end{tabular}
\end{table}
endsnippet

snippet fig "Figure environment" b
\begin{figure}[${1:htpb}]
	\centering
	${2:\includegraphics[width=0.8\textwidth]{$3}}
	\caption{${4:$3}}
	\label{fig:${5:${3/\W+/-/g}}}
\end{figure}
endsnippet

snippet enum "Enumerate" bA
\begin{enumerate}
	\item $0
\end{enumerate}
endsnippet

snippet item "Itemize" bA
\begin{itemize}
	\item $0
\end{itemize}
endsnippet

snippet desc "Description" b
\begin{description}
	\item[$1] $0
\end{description}
endsnippet

snippet pac "Package" b
\usepackage[${1:options}]{${2:package}}$0
endsnippet

snippet => "implies" Ai
\implies $0
endsnippet

snippet =< "implied by" Ai
\impliedby $0
endsnippet

context "math()"
snippet iff "iff" Ai
\iff $0
endsnippet


snippet mk "Mathk" iA
\( ${1:${VISUAL}} \) $0
endsnippet

snippet dm "DisplayMath" iA
\[
${1:${VISUAL}}
\] $0
endsnippet

#snippet &* "Fraction" iA
#\\frac{${1:${VISUAL}}}{$2} $0
#endsnippet





snippet ali "Align" bA
\begin{align*}
	${1:${VISUAL}}
\end{align*} $0
endsnippet


context "math()"
snippet // "Fraction" iA
\\frac{$1}{$2}$0
endsnippet


context "math()"
snippet / "Fraction" i
\\frac{${1:${VISUAL}}}{$2} $0
endsnippet



context "math()"
snippet '((\d+)|(\d*)(\\)?([A-Za-z]+)((\^|_)(\{\d+\}|\d))*)/' "symbol frac" wrA
\\frac{`!p snip.rv = match.group(1)`}{$1}$0
endsnippet

priority 1000
context "math()"
snippet '^.*\)/' "() frac" wrA
`!p
stripped = match.string[:-1]
depth = 0
i = len(stripped) - 1
while True:
	if stripped[i] == ')': depth += 1
	if stripped[i] == '(': depth -= 1
	if depth == 0: break;
	i-=1
snip.rv = stripped[0:i] + "\\frac{" + stripped[i+1:-1] + "}"
`{$1}$0
endsnippet

context "math()"
snippet '([A-Za-z])(\d)' "auto subscript" wrA
`!p snip.rv = match.group(1)`_`!p snip.rv = match.group(2)`
endsnippet

context "math()"
snippet '([A-Za-z])_(\d\d)' "auto subscript2" wrA
`!p snip.rv = match.group(1)`_{`!p snip.rv = match.group(2)`}
endsnippet

# priority 1000
# context "math()"
# snippet '^.*\)/' "() frac" wrA
# `!p
# stripped = match.string[:-1]
# depth = 0
# i = len(stripped) - 1
# while True:
#         if stripped[i] == ')': depth += 1
#         if stripped[i] == '(': depth -= 1
#         if depth == 0: break;
#         i-=1
# snip.rv = stripped[0:i] + "\\frac{" + stripped[i+1:-1] + "}"
# `{$1}$0
# endsnippet

# context "math()"
# snippet '([A-Za-z])(\d)' "auto subscript" wrA
# !p snip.rv = match.group(1)
# !p snip.rv = match.group(2)
# endsnippet

context "math()"
snippet '([A-Za-z])_(\d\d)' "auto subscript2" wrA
!p snip.rv = match.group(1)_{`!p snip.rv = match.group(2)`}
endsnippet


snippet sympy "sympyblock " w
sympy $1 sympy$0
endsnippet

priority 10000
snippet 'sympy(.*)sympy' "sympy" wr
`!p
from sympy import *
x, y, z, t = symbols('x y z t')
k, m, n = symbols('k m n', integer=True)
f, g, h = symbols('f g h', cls=Function)
init_printing()
snip.rv = eval('latex(' + match.group(1).replace('\\', '').replace('^', '**').replace('{', '(').replace('}', ')') + ')')
`
endsnippet

priority 1000
snippet math "mathematicablock" w
math $1 math$0
endsnippet

priority 10000
snippet 'math(.*)math' "math" wr
`!p
import subprocess
code = match.group(1)
code = 'ToString[' + code + ', TeXForm]'
snip.rv = subprocess.check_output(['wolframscript', '-code', code])
`
endsnippet


context "math()"
snippet == "equals" iA
&= $1 \\\\
endsnippet


context "math()"
snippet != "equals" iA
\neq $0
endsnippet


context "math()"
snippet qq "equals" iA
\, \quad \, $0
endsnippet


context "math()"
snippet QQ "equals" iA
\, \qquad \, $0
endsnippet



context "math()"
snippet != "equals" iA
\neq $0
endsnippet


context "math()"
snippet ceil "ceil" iA
\left\lceil $1 \right\rceil $0
endsnippet

context "math()"
snippet floor "floor" iA
\left\lfloor $1 \right\rfloor$0
endsnippet

context "math()"
snippet pmat "pmat" iA
\begin{pmatrix} $1 \end{pmatrix} $0
endsnippet


context "math()"
snippet bmat "bmat" iA
\begin{bmatrix} $1 \end{bmatrix} $0
endsnippet


context "math()"
snippet () "left( right)" iA
\left( ${1:${VISUAL}} \right) $0
endsnippet


context "math()"
snippet lr "left( right)" i
\left( ${1:${VISUAL}} \right) $0
endsnippet


context "math()"
snippet lr( "left( right" i
\left( ${1:${VISUAL}} \right) $0
endsnippet

context "math()"
snippet lr| "left| right|" i
\left| ${1:${VISUAL}} \right| $0
endsnippet

context "math()"
snippet lr{ "left\{ right\}" i
\left\\{ ${1:${VISUAL}} \right\\} $0
endsnippet

snippet lrb "left\{ right\}" i
\left\\{ ${1:${VISUAL}} \right\\} $0
endsnippet

context "math()"
snippet lr[ "left[ right]" i
\left[ ${1:${VISUAL}} \right] $0
endsnippet

snippet lra "leftangle rightangle" iA
\left<${1:${VISUAL}} \right>$0
endsnippet


context "math()"
snippet conj "conjugate" iA
\overline{$1}$0
endsnippet

context "math()"
snippet sum "sum" iA
\sum_{i=${1:1}}^{${2:\infty}} ${3:a_i} $0
endsnippet

context "math()"
snippet taylor "taylor" w
\sum_{${1:k}=${2:0}}^{${3:\infty}} ${4:c_$1} (x-a)^$1 $0
endsnippet

context "math()"
snippet lim "limit" w
\lim_{${1:n} \to ${2:\infty}} $0
endsnippet

context "math()"
snippet limsup "limsup" w
\limsup_{${1:n} \to ${2:\infty}}
endsnippet

context "math()"
snippet phi "phi" iA
\phi_{$1} ($2) $0
endsnippet


snippet prod "product" w
\prod_{${1:n=${2:1}}}^{${3:\infty}} ${4:${VISUAL}} $0
endsnippet


context "math()"
snippet pdv "d/dx" iA
\frac{\partial ${1:V}}{\partial ${2:x}} $0
endsnippet

snippet sqrt "\sqrt{}" iA
\sqrt{${1:${VISUAL}}} $0
endsnippet

#context "math()"
context "math()"
snippet td "to the ... power" iA
^{$1}$0
endsnippet


context "math()"
snippet fe "to the ... power" iA
_{$1}$0
endsnippet


context "math()"
snippet -= "_{ }" iA
\equiv $0
endsnippet

# context "math()"
# snippet rd "to the ... power" iA
# ^{($1)}$0
# endsnippet

snippet __ "subscript" iA
_{$1}$0
endsnippet

snippet ooo "\infty" iA
\infty
endsnippet

snippet rij "mrij" i
(${1:x}_${2:n})_{${3:$2}\\in${4:\\N}}$0
endsnippet

snippet <= "leq" iA
\le
endsnippet

snippet >= "geq" iA
\ge
endsnippet

snippet EE "geq" iA
\exists
endsnippet

snippet AA "forall" iA
\forall
endsnippet

context "math()"
snippet xnn "xn" iA
x_{n} $0
endsnippet

context "math()"
snippet ynn "yn" iA
y_{n} $0
endsnippet


context "math()"
snippet xii "xi" iA
x_{i} $0
endsnippet

context "math()"
snippet yii "yi" iA
y_{i} $0
endsnippet


context "math()"
snippet xjj "xj" iA
x_{j}
endsnippet


context "math()"
snippet yjj "yj" iA
y_{j}
endsnippet


context "math()"
snippet xp1 "x" iA
x_{n+1}
endsnippet

snippet xmm "x" iA
x_{m}
endsnippet

snippet R0+ "R0+" iA
\\R_0^+
endsnippet

snippet plot "Plot" w
\begin{figure}[$1]
	\centering
	\begin{tikzpicture}
		\begin{axis}[
			xmin= ${2:-10}, xmax= ${3:10},
			ymin= ${4:-10}, ymax = ${5:10},
			axis lines = middle,
		]
			\addplot[domain=$2:$3, samples=${6:100}]{$7};
		\end{axis}
	\end{tikzpicture}
	\caption{$8}
	\label{${9:$8}}
\end{figure}
endsnippet

context "math()"
snippet nn "Tikz node" w
\node[$5] (${1/[^0-9a-zA-Z]//g}${2}) ${3:at (${4:0,0}) }{$${1}$};
$0
endsnippet

context "math()"
snippet mcal "mathcal" iA
\mathcal{$1}$0
endsnippet


context "math()"
snippet lll "l" iA
\ell
endsnippet

context "math()"
snippet nabl "nabla" iA
\nabla
endsnippet

context "math()"
snippet xx "cross" iA
\times
endsnippet

context "math()"
priority 100
snippet * "cdot" iA
\cdot
endsnippet

context "math()"
snippet norm "norm" w
\|$1\|$0
endsnippet


context "math()"
snippet int "int" w
{\int_{$1}}^{$2} $0
endsnippet

context "math()"
snippet b/ "big frac" w
\big/ $0
endsnippet



context "math()"
snippet -> "to" iA
\to $0
endsnippet

context "math()"
snippet <-> "leftrightarrow" iA
\leftrightarrow $0
endsnippet

context "math()"
snippet !> "mapsto" iA
\mapsto $0
endsnippet

context "math()"
snippet invs "inverse" iA
^{-1}
endsnippet


context "math()"
snippet >> ">>" iA
\gg $0
endsnippet

context "math()"
snippet << "<<" iA
\ll $0
endsnippet


context "math()"
snippet ~ "" iA
\sim $0
endsnippet

context "math()"
snippet || "mid" iA
\mid $0
endsnippet


context "math()"
snippet notin "not in " iA
\not\in $0
endsnippet

context "math()"
snippet NN "n" iA
\N
endsnippet

context "math()"
snippet Nn "cap" iA
\cap
endsnippet

context "math()"
snippet UU "cup" iA
\cup
endsnippet

context "math()"
snippet uuu "bigcup" iA
\bigcup_{${1:i \in ${2: I}}} $0
endsnippet

context "math()"
snippet nnn "bigcap" iA
\bigcap_{${1:i \in ${2: I}}} $0
endsnippet

context "math()"
snippet OO "emptyset" iA
\O
endsnippet

context "math()"
snippet RR "real" iA
\R
endsnippet

context "math()"
snippet QQ "Q" iA
\Q
endsnippet

context "math()"
snippet ZZ "Z" iA
\Z
endsnippet

context "math()"
snippet <! "normal" iA
\triangleleft
endsnippet


context "math()"
snippet <> "hokje" iA
\diamond
endsnippet

context "math()"
snippet SI "SI" iA
\SI{$1}{$2}
endsnippet

context "math()"
snippet bigfun "Big function" iA
\begin{align*}
	$1: $2 &\longrightarrow $3 \\\\
	$4 &\longmapsto $1($4) = $0
.\end{align*}
endsnippet


context "math()"
snippet cvec "column vector" iA
\begin{pmatrix} ${1:x}_${2:1}\\\\ \vdots\\\\ $1_${2:n} \end{pmatrix}
endsnippet


context "math()"
priority 10
snippet "bar" "bar" riA
\overline{$1}$0
endsnippet


context "math()"
priority 100
snippet "([a-zA-Z])bar" "bar" w
\overline{`!p snip.rv=match.group(1)`}
endsnippet

context "math()"
priority 10
snippet "hat" "hat" w
\hat{$1}$0
endsnippet


context "math()"
priority 100
snippet "([a-zA-Z])hat" "hat" w
\hat{`!p snip.rv=match.group(1)`}
endsnippet


context "math()"
snippet letw "let omega" iA
Let $\Omega \subset \C$ be open.
endsnippet



context "math()"
snippet HH "H" iA
\mathbb{H}
endsnippet


context "math()"
snippet DD "D" iA
\mathbb{D}
endsnippet

snippet txtit "cursive text" A
\textit{${1:${VISUAL}}} $0
endsnippet

context "math()"
snippet txt "math()" A
\text{${1:${VISUAL}}} $0
endsnippet


context "math()"
snippet tbf "math()" A
\textbf{${1:${VISUAL}}} $0
endsnippet


context "math()"
snippet abs "absolutevalue" bA
\abs{ ${1:${VISUAL}} } $0
endsnippet

# vim:ft=snippets
